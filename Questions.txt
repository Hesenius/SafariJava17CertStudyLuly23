Q) Which are legal:

   A) class X {
        var x = 99;
      }
   B) void doStuff(var x) { }
   C) void doStuff() {
        var x;
        x = 100;
      }
   D) void doStuff() {
        var x = 100;
      }
   E) void doStuff() {
        var x = null;
      }

Q)
A) for (var x = 0; x < 3; x++)
System.out.println(x);

B) try (var in = new FileReader("");
var out = new FileWriter("")) {
}

C) try (FileReader in = new FileReader("")) {
} catch (var ex) { }

D) void doStuff() {
var x = new int[]{ 1, 2, 3 };
}

E) void doStuff() {
var x = { 1, 2, 3 };
}

Q) Given:
var x = true ? "99" : 99;

What is the type of x?
A) none, it's fails to compile
B) int
C) String
D) Object
E) none of the above

Q)  Given:

String s1 = new String("Hello");
s1.concat(" world");
System.out.println(s1);

What is the output?
A) Hello World
B) Hello
C) World
D) Doesn't compile
E) Exception at runtime

Q) Given:
   
    String message = """Hello\
    Java 17 World!""";
    System.out.println(message + "XXX");

What is the result?
A) Compilation fails
B) Exception at runtime
C) Hello
   Java 17 World!XXX
D) Hello Java 17 World!XXX
E) Hello Java 17 World!
   XXX

Q) Given:
    String message = """
        Hello
            Java 17 World!""";
    System.out.println(message + "XXX");
What is the result?
A)
Hello
Java 17 World!XXX
B)
Hello
    Java 17 World!XXX
C)
Hello
Java 17 World!
XXX
D)
    Hello
        Java 17 World!
XXX

Q) Given:

public static void main(String[] args) {
  int x = -1;
  System.out.println(x & 5);
}

What is the result?
A) Compilation fails
B) Exception at runtime
C) -1
D) 0x00000005
E) 5

Q) Given:
  public static boolean getValue() {
    System.out.println("Getting value");
    return true;
  }

and:

boolean b1 = false;
System.out.println(b1 & getValue());

What is the result:
A) Compilation fails
B) false
C) true
D) Getting value
   false
E) Getting value
   true

Q) Which print "true"
A) String s = "Hello";
   String t = "He";
   t += "llo";
   sout(s == t);
B) String s = "Hello";
   String t = "He";
   t += "llo";
   sout(s.equals(t));
C) StringBuilder s = new StringBuilder("Hello");
   StringBuilder t = new StringBuilder("He");
   t.append("llo");
   sout(s.equals(t));
D) List<String> ls = List.of("Fred", "Jim");
   List<String> ls2 = new ArrayList<>(ls);
   sout(ls.equals(ls2));
E) LocalDate ld = LocalDate.of(2021, 3, 29);
   LocalDate ld2 = LocalDate.of(2021, 3, 29);
   sout(ld.equals(ld2));

Q) Given:
class X {
  static String h = "Hel" + "lo";
}
And, in a separately compiled source file:
    String s1 = "Hello";
    String s2 = new StringBuilder("Hello").toString();
    String s3 = s2.intern();

Which are true?
A) s1 == s2
B) s2 == s3
C) s1 == s3
D) X.h == s1
E) None of the above

Q) Given:
class Base {
  void doBaseStuff() { System.out.println("doBaseStuff"); }
}
and:
class Sub extends Base {
  void doBaseStuff() { System.out.println("doSubStuff"); }
  void doOtherStuff() { System.out.println("doOtherStuff"); }
}
and:
  Base b = new Sub();
  ((Sub) b).doOtherStuff();

What is the result?
A) doSubStuff
B) doOtherStuff
C) doBaseStuff
D) Exception at runtime
E) Compilation failure

Q) Given:
class Base {
  void doBaseStuff() { System.out.println("doBaseStuff"); }
}

class Sub extends Base {
  void doBaseStuff() { System.out.println("doSubStuff"); }
  void doOtherStuff() { System.out.println("doOtherStuff"); }
}

  Base b = new Sub();
  ((Runnable) b).run();

What is the result?
A) doSubStuff
B) doOtherStuff
C) doBaseStuff
D) Exception at runtime
E) Compilation failure

Q) Given:
    Object obj = "Hello";
    boolean answered = false;
    if (obj instanceof String) {
      String str = (String)obj;
      if (str.length() > 3) {
        System.out.println(str);
        answered = true;
      }
    }
    if (!answered) System.out.println("Nope");
Which replace the if clause to produce the same output?
A)    System.out.println(obj instanceof String str && str.length() > 3 ? str : "Nope");
B)    if (obj instanceof String str when str.length() > 3)
        System.out.println(str);
      else
        System.out.println("Nope");
C)    if (obj instanceof String str if str.length() > 3)
        System.out.println(str);
      else
        System.out.println("Nope");
D)    System.out.println(obj instanceof String.class str && str.length() > 3 ? str : "Nope");
E)    if (!(obj instanceof String str) || str.length() <= 3)
        System.out.println("Nope");
      else
        System.out.println(str);

Q)
Which print true?
Iterable<String> is = List.of("a", "b", "c");
Object obj = is;
A)
System.out.println(is instanceof List);
B)
System.out.println(obj instanceof List l && l.size() > 2);
C)
System.out.println(obj instanceof List<String> ls);
D)
System.out.println(is instanceof Collection<? extends CharSequence> cs);
E)
System.out.println(is instanceof List<String> ls || ls.size() > 2);

Q) Given:
String s = "Hello";
switch (s) {
  case "Hello" ->
      System.out.print("Bonjour "); // line n1
      System.out.print("Guten Tag ");
  default -> System.out.print("Bye");
}

Which is true?
A) The code prints: Bonjour Guten Tag Bye
B) The code prints: Bonjour Guten Tag
C) If line n1 is removed the code prints: Guten Tag Bye
D) If line n1 is removed the code prints: Guten Tag
E) The code fails to compile

Q) Given:
int x = 1;
// line n1
switch(x) {
  case 1: LocalDate.of(2023, x, 1);
  default: LocalDate.of(2022, 12, 1);
};

Which are true?
A) The code compiles
B) The code throws an exception at runtime
C) The code compiles if line n1 is replaced with
   var d =
D) The code compiles if the word "yield" is inserted
   after the colon in both the case and default
E) The code compiles if the changes of both C and D
   are applied

Q) Given
  void doStuff() throws IOException {};
  void doStuff2() throws FileNotFoundException {};
And:
  void tryStuff() {
    try {
      doStuff();
      doStuff2();
    } enter code here {
      // handle both exceptions
    }
  }
What can be inserted at "enter code here"
to provide handling of exceptions from both
methods?
A) catch (IOException | FileNotFoundException e)
B) catch (FileNotFoundException | IOException e)
C) catch (FileNotFoundException e)
D) catch (IOException e)
E) finally

Q) Given:
class AC implements AutoCloseable {
  private String name;
  public AC(String name) { this.name = name; }
  @Override public void close() { System.out.println("Closing " + name); }
}
And:
  var ac0 = new AC("zero");
  try ( var ac1 = new AC("one"); var ac2 = new AC("two"); ac0; ) {}

What is the result?
A) Compilation fails
B) Closing zero
   Closing two
   Closing one
C) Closing zero
   Closing one
   Closing two
D) Closing two
   Closing one
   Closing zero
E) Closing one
   Closing two
   Closing zero

Q) Given
public int getValue() {return 1;}
public CharSequence getText() {return null;}

which of these methods may individually be added to a subclass of this class?

A) public int getValue(int x) {return 1;}
B) public String getValue() {return "Hello";}
C) public String getValue(int x) {return "Hello";}
D) public StringBuilder getText() { return null; }
E) public Object getText() { return ""; }

Q) Given:
void doStuff(int x, int y) {}         // Method A
void doStuff(int x, long y) {}        // Method B
void doStuff(long x, int y) {}        // Method C
void doStuff(int ... x) {}            // Method D
void doStuff(Integer x, Integer y) {} // Method E

void tryStuff() {
  doStuff(1, 2);
}
Given all five methods exist, which is invoked by the invocation in the body of method tryStuff()?

Q) Given:
void doStuff(int x, long y) {}        // Method B
void doStuff(long x, int y) {}        // Method C
void doStuff(int ... x) {}            // Method D
void doStuff(Integer x, Integer y) {} // Method E

void tryStuff() {
  doStuff(1, 2);
}
Given all five methods exist, which is invoked by the invocation in the body of method tryStuff()?
A) does not compile

Q) Given:
enum Day {
  MONDAY(1), TUESDAY;
  public Day(int d) {}
  public Day() {}
}
and:
sout(Day.MONDAY)

What is the result?
A) 1
B) MONDAY
C) Day.MONDAY
D) Exception at runtime
E) Compilation fails

Q) Given:
enum Suit { HEARTS, DIAMONDS, CLUBS, SPADES;
  boolean isTrumps() { return this == HEARTS; }
}

Which is/are true?
A) isTrumps is implicitly static
B) isTrumps can be marked final
C) if it's necessary to prevent isTrumps being overridden,
   it should be marked final
D) isTrumps fails to compile
E) none of the above

Q) Given:
record Customer(String name, int id) {
  // line n1
}

Which are valid at line n1?
A)  Customer(String name, int id) {
      this.name = "Mx. " + name;
    }
B)  Customer {
      this.name = name;
      this.id = id;
    }
C)  Customer {
      if (name == null || name.length() == 0 || id < 1)
        throw new IllegalArgumentException("Bad Customer values");
      name = "Mr/Mrs/Ms " + name;
    }
D)  static {}
E)  {}

Q)
record Client(String name, int creditLimit) {
  line n1
 A) At line n1
    public Client(String name) {
      this(name, 0);
    }

 B) at line n1
    public Client(String name, int creditLimit) {
      super();
      this.name = name;
      this.creditLimit = creditLimit;
    }

 C) as a separate declaration:
    record SpecialClient(String name, int creditLimit, String greeting)
      extends Client(name, creditLimit) {}

 D) at line n1
    private Client() {
      this("Unknown", 0);
    }

 E) at line n1
    Client {}

Q) Given:
record Fruit(String type, String color) {}
public class Q3equalsandfieldaccess {
  public static void main(String[] args) {
/*
and:
    Fruit f1 = new Fruit("banana", "yellow");
    Fruit f2 = new Fruit("banana", "yellow");
    // line n1
}
Which is/are true at line n1
A)    System.out.println(f1 == f2);  prints true
B)    System.out.println(f1.equals(f2));  prints true
C)    f1.color = "brown"; is valid
D)    System.out.println(f1.color); prints yellow
E)    System.out.println(f1.color()); prints yellow

Q) Given:
record SalesItem(String description, int price) {
     // line n1
}
Which can be added individually at line n1?
A) private int stockOnHand;
B) @Override public int price() { return price; }
C) @Override public int price() { return super.price() + 10; }
D) static String ourStore;
E) public int getDiscount() { return price / 10; }

Q) public class AnonymousQ1 {
public void doStuff() {
  int len = 3;
  Predicate<String> ps = new Predicate<String>() {
    @Override
    public boolean test(String s) {
      return s.length() > len; // line n1
    }
  };
  // line n2
}

  Which are true?
  A) The code compiles
  B) Compilation fails due to a problem at line n1
  C) adding the code
System.out.println("testing lines " + (++len));
  at line n2 is OK

Q) Given:
class Outer1 {
  class Inner1 {
    private int y = 100;
    // line n1
  }
  private int x = 99;
  // line n2
}
and these method proposals:
void showX() { sop("x is " + x); }
void showY() { sop("y is " + y); }
void showAnotherY(Inner1 another) { sop("y is " + another.y); }
static Inner1 makeOne() { return new Inner1(); }
Which is/are true?
A) showX can be added at line n1
B) showY can be added at line n2
C) showAnotherY can be added at line n2
D) makeOne can be added at line n1
E) makeOne can be added at line n2
